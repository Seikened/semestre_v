# -*- coding: utf-8 -*-
"""Proyecto5_ACO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ya3gf0V1T3UjU0-pcjMxuZ4Wxdctn4-9

# Proyecto 5

## Objetivo:
Implementar un algoritmo de optimización por colonia de hormigas (ACO) para encontrar el camino óptimo entre el inicio y la salida de un laberinto, utilizando un modelo basado en feromonas y heurísticas de distancia que permita observar el comportamiento colectivo emergente de la colonia.
"""

import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import networkx as nx
import random
import math

laberinto = [
    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1],
    [1, 1, 1, 0, 1, 0, 0, 1, 0 ,1, 0, 1, 0, 1, 0],
    [0, 0, 1, 0, 1, 1, 0 ,1, 1, 1, 0, 1, 1, 1, 1],
    [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0 ,0 ,0 ,1],
    [0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
    [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],
    [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
    [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1],
]

def laberinto_a_grafo(lab):
    grafo = {}
    filas = len(lab)
    columnas = len(lab[0])

    for i in range(filas):
        for j in range(columnas):
            if lab[i][j] == 1:
                nodo = (i, j)
                grafo[nodo] = {}

                vecinos = [
                    (i-1, j),
                    (i+1, j),
                    (i, j-1),
                    (i, j+1)
                ]

                for (x, y) in vecinos:
                    if 0 <= x < filas and 0 <= y < columnas:
                        if lab[x][y] == 1:
                            grafo[nodo][(x, y)] = 1

    return grafo


# --- 1. PARÁMETROS DEL PROBLEMA ---
GRAFO_DISTANCIAS = laberinto_a_grafo(laberinto)
NODO_INICIO = (0, 0)
NODO_FINAL = (14, 14)
ALL_NODES = list(GRAFO_DISTANCIAS.keys())
NUM_NODOS = len(ALL_NODES)

# --- 2. PARÁMETROS ACO ---
NUM_HORMIGAS = 2
NUM_ITERACIONES = 10
RHO = 0.01       # Tasa de evaporación
Q = 1.0          # Constante de depósito de feromona
ALFA = 1.0       # Influencia del rastro de feromona
BETA = 1.0       # Influencia de la heurística (visibilidad)

# --- 3. FUNCIONES PRINCIPALES ---

def inicializar_feromonas(grafo):
    feromonas = {}
    for i in grafo:
        feromonas[i] = {}
        for j in grafo[i]:
            feromonas[i][j] = 0.1  # valor inicial
    return feromonas


def probabilidad_movimiento(actual, nodos_no_visitados, feromonas, grafo, alpha, beta):
    total = 0.0
    probabilidades = {}

    # Calcula el denominador (la suma de todos los pesos posibles)
    for siguiente in nodos_no_visitados:
        if siguiente in grafo[actual]:
            tau = feromonas[actual][siguiente]
            eta = 1.0 / grafo[actual][siguiente]
            total += (tau ** alpha) * (eta ** beta)

    # Calcula la probabilidad normalizada para cada destino
    for siguiente in nodos_no_visitados:
        if siguiente in grafo[actual]:
            tau = feromonas[actual][siguiente]
            eta = 1.0 / grafo[actual][siguiente]
            prob = ((tau ** alpha) * (eta ** beta)) / total
            probabilidades[siguiente] = prob

    return probabilidades


def seleccionar_nodo(probabilidades):
    r = random.random()
    acumulada = 0.0
    for nodo, prob in probabilidades.items():
        acumulada += prob
        if r <= acumulada:
            return nodo
    # Si por redondeo no se elige ninguno
    return list(probabilidades.keys())[-1]


def construir_ruta(feromonas, grafo, alpha, beta):
    ruta = [NODO_INICIO]
    actual = NODO_INICIO
    nodos_no_visitados = ALL_NODES.copy()
    nodos_no_visitados.remove(actual)

    while actual != NODO_FINAL and len(nodos_no_visitados) > 0:
        probabilidades = probabilidad_movimiento(actual, nodos_no_visitados, feromonas, grafo, alpha, beta)
        if not probabilidades:
            break
        siguiente = seleccionar_nodo(probabilidades)
        ruta.append(siguiente)
        actual = siguiente
        if siguiente in nodos_no_visitados:
            nodos_no_visitados.remove(siguiente)

    return ruta


def calcular_longitud_ruta(ruta, grafo):
    distancia = 0.0
    for i in range(len(ruta) - 1):
        a, b = ruta[i], ruta[i+1]
        if b in grafo[a]:
            distancia += grafo[a][b]
        else:
            # Si no existe conexión directa, penalizamos
            distancia += 9999
    return distancia


def actualizar_feromonas(feromonas, rutas, distancias, rho, q):
    # Evaporación
    for i in feromonas:
        for j in feromonas[i]:
            feromonas[i][j] *= (1 - rho)

    # Deposito de feromonas
    for k in range(len(rutas)):
        ruta = rutas[k]
        dist = distancias[k]
        for i in range(len(ruta) - 1):
            a, b = ruta[i], ruta[i+1]
            if b in feromonas[a]:
                feromonas[a][b] += q / dist


def aco(devolver_historial=False):
    feromonas = inicializar_feromonas(GRAFO_DISTANCIAS)
    mejor_ruta = None
    mejor_distancia = math.inf

    historial_mejor_ruta = []      # mejor ruta en cada iteración
    historial_mejor_dist = []      # mejor distancia en cada iteración

    for iteracion in range(NUM_ITERACIONES):
        rutas = []
        distancias = []

        for i in range(NUM_HORMIGAS):
            ruta = construir_ruta(feromonas, GRAFO_DISTANCIAS, ALFA, BETA)
            distancia = calcular_longitud_ruta(ruta, GRAFO_DISTANCIAS)
            rutas.append(ruta)
            distancias.append(distancia)

            if distancia < mejor_distancia and ruta[-1] == NODO_FINAL:
                mejor_ruta = ruta
                mejor_distancia = distancia

        actualizar_feromonas(feromonas, rutas, distancias, RHO, Q)

        # guardamos el mejor hasta ese momento (puede ser None al inicio)
        historial_mejor_ruta.append(mejor_ruta.copy() if mejor_ruta is not None else None)
        historial_mejor_dist.append(mejor_distancia)

        print(f"Iteración {iteracion+1}: Mejor distancia = {mejor_distancia:.3f}")

    print("\n--- RESULTADO FINAL ---")
    print(f"Mejor ruta encontrada: {mejor_ruta}")
    print(f"Distancia total: {mejor_distancia:.3f}")

    if devolver_historial:
        return mejor_ruta, mejor_distancia, historial_mejor_ruta, historial_mejor_dist
    return mejor_ruta, mejor_distancia





def visualizar_laberinto(lab, ruta=None):
    """
    Visualiza el laberinto como una cuadrícula, marcando:
    - Celdas transitables (1) en blanco
    - Paredes (0) en negro
    - Nodo de inicio (verde)
    - Nodo final (rojo)
    - Ruta encontrada (línea naranja)
    """
    filas = len(lab)
    columnas = len(lab[0])

    plt.figure(figsize=(8, 8))

    # 0 = negro, 1 = blanco (pared negro, camino blanco)
    matriz = [[lab[i][j] for j in range(columnas)] for i in range(filas)]
    plt.imshow(matriz, cmap="gray", origin="upper")  # <- origin="upper" y SIN invertir eje Y

    # Cuadrícula alineada con las celdas
    plt.xticks(range(columnas))
    plt.yticks(range(filas))
    plt.gca().set_xticks([x - 0.5 for x in range(1, columnas)], minor=True)
    plt.gca().set_yticks([y - 0.5 for y in range(1, filas)], minor=True)
    plt.grid(which="minor", color="lightgrey", linestyle="-", linewidth=0.5)

    # NO invertimos el eje Y, porque origin="upper" ya coloca (0,0) arriba-izquierda
    # plt.gca().invert_yaxis()  # <- esto lo quitamos

    # Marcar inicio y fin
    inicio_x, inicio_y = NODO_INICIO[1], NODO_INICIO[0]
    fin_x, fin_y = NODO_FINAL[1], NODO_FINAL[0]

    plt.scatter(inicio_x, inicio_y, c="limegreen", s=200,
                marker="o", edgecolors="black", label="Inicio")
    plt.scatter(fin_x, fin_y, c="red", s=200,
                marker="o", edgecolors="black", label="Salida")

    # Dibujar la ruta si existe
    if ruta:
        xs = [n[1] for n in ruta]
        ys = [n[0] for n in ruta]
        plt.plot(xs, ys, color="orange", linewidth=3, label="Ruta ACO", alpha=0.9)
        plt.scatter(xs, ys, c="orange", s=80, edgecolors="black")

    plt.title("Laberinto y ruta de la colonia de hormigas")
    plt.legend(loc="upper right")
    plt.tight_layout()
    plt.show()
    





def animar_convergencia(lab, historial_rutas, interval=500):
    filas = len(lab)
    columnas = len(lab[0])

    fig, ax = plt.subplots(figsize=(8, 8))

    matriz = [[lab[i][j] for j in range(columnas)] for i in range(filas)]
    ax.imshow(matriz, cmap="gray", origin="upper")

    ax.set_xticks(range(columnas))
    ax.set_yticks(range(filas))
    ax.set_xticks([x - 0.5 for x in range(1, columnas)], minor=True)
    ax.set_yticks([y - 0.5 for y in range(1, filas)], minor=True)
    ax.grid(which="minor", color="lightgrey", linestyle="-", linewidth=0.5)

    inicio_x, inicio_y = NODO_INICIO[1], NODO_INICIO[0]
    fin_x, fin_y = NODO_FINAL[1], NODO_FINAL[0]

    ax.scatter(inicio_x, inicio_y, c="limegreen", s=200,
               marker="o", edgecolors="black", label="Inicio")
    ax.scatter(fin_x, fin_y, c="red", s=200,
               marker="o", edgecolors="black", label="Salida")

    linea_ruta, = ax.plot([], [], color="orange", linewidth=3, label="Mejor ruta")
    ax.legend(loc="upper right")

    def init():
        linea_ruta.set_data([], [])
        ax.set_title("Sin solución todavía")
        return linea_ruta,

    def update(frame):
        ruta = historial_rutas[frame]
        if ruta is None:
            linea_ruta.set_data([], [])
            ax.set_title(f"Iteración {frame+1}: sin ruta completa aún")
        else:
            xs = [n[1] for n in ruta]
            ys = [n[0] for n in ruta]
            linea_ruta.set_data(xs, ys)
            ax.set_title(f"Iteración {frame+1}: mejor ruta encontrada")

        return linea_ruta,

    anim = FuncAnimation(
        fig,
        update,
        frames=len(historial_rutas),
        init_func=init,
        blit=False,
        interval=interval,
        repeat=True
    )

    plt.tight_layout()
    plt.show()
    return anim

if __name__ == "__main__":
    mejor_ruta, mejor_distancia, historial_rutas, historial_dist = aco(devolver_historial=True) # type: ignore

    from IPython.display import HTML
    from matplotlib import rc

    rc('animation', html='jshtml')  # para que use JS en lugar de video

    anim = animar_convergencia(laberinto, historial_rutas)
    HTML(anim.to_jshtml())
    